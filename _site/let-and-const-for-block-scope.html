<p>Up until ES6, you couldn’t achieve true block scoping in JavaScript. With the <code class="highlighter-rouge">var</code> keyword, the scope in a code block could be accessed in the global scope, as variable declarations are hoisted to the top of scope and the assignments are kept where they are.</p>

<p>For instance, take this code:</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="c1">// some code</span>

	<span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// ...</span>
	<span class="p">}</span>

	<span class="c1">// more code</span>

	<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The function <code class="highlighter-rouge">foo</code> sits in the global scope. Inside the <code class="highlighter-rouge">foo</code> function, we have the function <code class="highlighter-rouge">bar</code> as well as some variable assignments with <code class="highlighter-rouge">var b = 2 </code> and <code class="highlighter-rouge">var c - 3</code> sitting in <code class="highlighter-rouge">foo</code>. Each of these identifiers and functions have access to the scopes outside of them, clouding the global namespace. We call these <em>function scopes</em> and typically, they aren’t a good idea.</p>

<h2 id="examples-of-hoisting">Examples of Hoisting</h2>

<p>One of the reasons it isn’t great to use <code class="highlighter-rouge">var</code> when declaring variable assignments is because of hoisting which I mentioned above. An example:</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code>   <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
	  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	  <span class="p">}</span>
	   <span class="nx">alert</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="nx">bar</span><span class="p">();</span> <span class="c1">// alerts 10 instead of reference error  </span>
</code></pre>
</div>
<p>Instead of getting a reference error here, when <code class="highlighter-rouge">bar()</code> is executed, the <code class="highlighter-rouge">alert(foo)</code> function has access to <code class="highlighter-rouge">var foo = 10;</code> in the conditional block. So when the JavaScript compiler goes looking for <code class="highlighter-rouge">foo</code> it finds it because <code class="highlighter-rouge">foo</code> is not scoped solely to the conditional block.</p>

<h2 id="let"><code class="highlighter-rouge">let</code></h2>

<p>With ES6 <sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>, you can create a block scope, or a scope that is contained within its own code block, by using <code class="highlighter-rouge">let</code> instead of <code class="highlighter-rouge">var</code>. For instance:</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
	  <span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// Reference Error! a is not defined.</span>
</code></pre>
</div>
<p>Here, the <code class="highlighter-rouge">console.log(b);</code> method call is looking for <code class="highlighter-rouge">a</code> but <code class="highlighter-rouge">console.log</code> can’t access <code class="highlighter-rouge">a</code> as it is scoped to the <code class="highlighter-rouge">if</code> block. This is a very simplistic example of block scoping with <code class="highlighter-rouge">let</code>.</p>

<h2 id="const"><code class="highlighter-rouge">const</code></h2>

<p><code class="highlighter-rouge">const</code> also creates block scoping. It allows for the value the indentifier holds to be quasi immutable. The data <em>can</em> be mutated as <code class="highlighter-rouge">const</code> is only really immutable because it binds the value of the indentifier and should only be used when you want the value you’re using to be non-reassignable.</p>

<p>You can make a <code class="highlighter-rouge">const</code> value immutable by adding <code class="highlighter-rouge">object.freeze()</code> method to it.</p>

<h2 id="what-should-you-use">What Should You Use?</h2>

<p>I’ll leave you with a quote by <a href="https://twitter.com/getify">Kyle Simpson</a>:</p>

<blockquote>
  <p>let improves scoping options in JS, not replaces. var is still a useful signal for variables that are used throughout the function. Having both, and using both, means scoping intent is clearer to understand and maintain and enforce. That’s a big win!</p>
</blockquote>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>ES2015. Sorry. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
